module Main where

-- Haskell module generated by the BNF converter

import Text.Show.Pretty 
import LexMp
import ParMp
import ErrM
import System.Environment
import AbsMp
import SkelMp
import AST
import SymbolTable
--import Semantic
import IR

gen_ST_Prog :: M_prog -> I_prog
gen_ST_Prog (M_prog (ds, sts)) = IPROG (fs', nv, arrs', sts')
   where
     st  = new_scope L_PROG empty
     (n, st')  = gen_ST_Decls 0 st ds
	 
     vs = filter isVar ds
	 
     nv = length vs
     arrs = filter isArray vs  -- M_var (String,[M_expr],M_type)
     arrs' = map (\a -> transArray a st') arrs    -- (Int,[I_expr])
	 
     fs = filter isFun ds
     fs' = transFuns fs st'
     st'' = gen_ST_Stmts n st' sts
     sts' = transStmts sts st''

gen_ST_Decls :: Int -> ST -> [M_decl] -> (Int, ST)
gen_ST_Decls n st [] = (n, st)
gen_ST_Decls n st decls = (n'', st'')
     where 
        vs = filter isVar decls
        fs = filter isFun decls
        (d:rest) = vs++fs
        (n', st')   = gen_ST_Decl n st d
        (n'', st'') = gen_ST_Decls n' st' rest

gen_ST_Decl :: Int -> ST -> M_decl -> (Int, ST)
gen_ST_Decl n st d = proc_d n st d
   where
     add_args n st [] = st
     add_args n st ((name, dim, typ):ps) = add_args n' st' ps
       where (n', st') = insert n st (ARGUMENT (name, typ, dim)) 
	 
     proc_d n st d = case d of
       M_var (name, arrSize, typ) -> (n, st')
	     where (fn, st') = insert n st (VARIABLE (name, typ, length arrSize))     
       M_fun (name,pL,rT,ds,_) -> (n'', st'''')
         where 
           (n', st') = insert (n+1) st (FUNCTION (name, [], rT))
           st'' = new_scope (L_FUN rT) st'
           st''' = add_args n' st'' pL
           (n'', st'''') = gen_ST_Decls n' st''' ds
		   
gen_ST_Stmts :: Int -> ST -> [M_stmt] -> ST
gen_ST_Stmts n st [] = st 
gen_ST_Stmts n st (s:rest) = st''
    where
       st'  = gen_ST_Stmt n st s
       st'' = gen_ST_Stmts n st' rest

gen_ST_Stmt :: Int -> ST -> M_stmt -> ST
gen_ST_Stmt n st d = case d of
	M_cond (e, s1, s2) -> st''
           where 
              st' = gen_ST_Stmt n st s1
              st'' = gen_ST_Stmt n st' s2
	M_block (decls, stmts) -> st''
           where 
              st' = new_scope L_BLK st
              (n', st'') = gen_ST_Decls n st' decls
	x -> st

			 
main = do
    args <- getArgs
    conts <- readFile (args !! 0)
    let tok = tokens conts
    let ptree = pProg tok       
    putStrLn "The AST Tree:\n"
    case ptree of
        Ok  tree -> do
            let ast = transProg tree
            let st = gen_ST_Prog ast 
            putStrLn $ ((ppShow ast) ++ "\n\n" ++ (ppShow st))
        Bad msg-> putStrLn msg
