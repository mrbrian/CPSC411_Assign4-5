module Main where

-- Haskell module generated by the BNF converter

import Text.Show.Pretty 
import LexMp
import ParMp
import ErrM
import System.Environment
import AbsMp
import SkelMp
import AST
import SymbolTable
		
process :: M_prog -> ST
process (M_prog (ds, _)) = st'
	where
		st = new_scope L_PROG empty
		st' = process_decls 0 st ds

-- 
process_decls :: Int -> ST -> [M_decl] -> ST
process_decls n st [] = st
process_decls n st (d : rest) = st''
     where 
        st' = process_decl n st d 
        st'' = process_decls n st' rest
--   M_fun (String,[(String,Int,M_type)],M_type,[M_decl],[M_stmt]) ->
--   M_data (String,[(String,[M_type])]) ->
--   ARGUMENT (name, ty, val) -> insert n? (process_decl st d) : (process_decls rest)


process_decl :: Int -> ST -> M_decl -> ST
process_decl n st d = proc_d n st d
   where
     count_dim n [] = n
     count_dim n (x:xs) = count_dim (n+1) xs     
     
     add_args n st [] = st
     add_args n st ((name, dim, typ):ps) = add_args n' st' ps
       where (n', st') = insert n st (ARGUMENT (name, typ, dim)) 
	 
     proc_d n st d = case d of
       M_var (name, arrSize, typ) -> st'
	     where (fn, st') = insert n st (VARIABLE (name, typ, count_dim 0 arrSize))     
       M_fun (name,pL,rT,ds,_) -> st''''
         where 
           (n', st') = insert (n+1) st (FUNCTION (name, [], rT))
           st'' = new_scope (L_FUN rT) st'
           st''' = add_args n' st'' pL
           st'''' = process_decls n' st''' ds
        
--process_params
{-
process_stmt :: Int -> ST -> M_stmt -> ST
process_stmt n st d = case d of
	M_case (ex, ((cId, vars, stmt):cs)) -> st'
          where 
            st' = new_scope L_CASE st
-}
--(M_expr,[(String,[String],M_stmt)])
--(the expression,[(constructor,[vars],exec)])


-- every M_decl node 
   
main = do
    args <- getArgs
    conts <- readFile (args !! 0)
    let tok = tokens conts
    let ptree = pProg tok       
    putStrLn "The AST Tree:\n"
    case ptree of
        Ok  tree -> do
            let ast = transProg tree
            putStrLn $ ((ppShow ast) ++ "\n\n")
        Bad msg-> putStrLn msg
